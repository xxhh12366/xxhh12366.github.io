<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>opencv学习（2）</title>
      <link href="/2025/02/05/2025-02-05-Opencv%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
      <url>/2025/02/05/2025-02-05-Opencv%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在VS中使用Opencv<br>每个项目单独导入opencv（在项目属性的包含目录与库目录的）<br>链接器导入对应版本的lib</p><p>Background:<br>0 &#x3D; black<br>255 &#x3D; white<br>8 bits &#x3D; 256 levels</p><p><strong>1. 导入图像视频和网络摄像头</strong><br>常用头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>opencv学习（1）</title>
      <link href="/2025/02/04/2025-02-04-Opencv%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
      <url>/2025/02/04/2025-02-04-Opencv%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><em><strong>关于python下的opencv简单使用</strong></em></p><p><strong>1. 取色，显示灰度图</strong><br>对于Opencv，存储一张彩色图片等同于存储三张灰度图（范围为0-255）<br>三张灰度图存储在图像数据的第三个维度上，对颜色的存储数据与RGB相反</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&quot;blue&quot;</span>, image[:, :, <span class="number">0</span>])</span><br><span class="line">cv2.imshow(<span class="string">&quot;green&quot;</span>, image[:, :, <span class="number">1</span>])</span><br><span class="line">cv2.imshow(<span class="string">&quot;red&quot;</span>, image[:, :, <span class="number">2</span>])  </span><br></pre></td></tr></table></figure><p><strong>2. 彩色图像的灰度变换算法</strong><br>将三个彩色通道的图像作平方和加权平均<br>其图像也可视作相机cmos芯片上接受光子数的分布图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;gray&#x27;</span>, gray)</span><br></pre></td></tr></table></figure><p><strong>3. 图像的裁剪</strong><br>使用索引号取出图像的一部分<br>索引顺序为先横行后纵列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crop = image[<span class="number">100</span>:<span class="number">150</span>, <span class="number">100</span>:<span class="number">150</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>, crop)</span><br></pre></td></tr></table></figure><p><strong>4. Opencv的绘制功能，需要使用numpy工具包</strong><br>Opencv 图像数据，实际是numpy数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">image = np.zeros([<span class="number">300</span>, <span class="number">300</span>, <span class="number">3</span>], np.uint8)</span><br><span class="line"><span class="comment">#空白画布</span></span><br><span class="line"><span class="comment">#300 行、300 列，且每个元素有 3 个通道的矩阵</span></span><br><span class="line"><span class="comment">#np.uint8 表示无符号 8 位整数，取值范围是 0 到 255，这也是图像数据中常用的数据类型</span></span><br><span class="line">cv2.line(image, (<span class="number">0</span>, <span class="number">0</span>), (<span class="number">300</span>,<span class="number">300</span>), (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line"><span class="comment">#线段的，起点坐标，终点坐标，颜色，粗细</span></span><br><span class="line"><span class="comment">#这里的color=(255,0,0)指的是，blue为255</span></span><br><span class="line">cv2.rectangle(image, (<span class="number">0</span>, <span class="number">20</span>), (<span class="number">20</span>,<span class="number">40</span>), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">cv2.circle(image, (<span class="number">20</span>, <span class="number">20</span>), <span class="number">20</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">1</span>)<span class="comment">#粗细为负，表示填充</span></span><br><span class="line">cv2.putText(image, <span class="string">&quot;hello&quot;</span>, (<span class="number">100</span>,<span class="number">50</span>), <span class="number">0</span>,<span class="number">1</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><p><strong>5. Opencv的均值滤波</strong><br>使用均值滤波器处理图片中的噪点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">guess = cv2.GaussianBlur(image,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment">#最后一个数，意为sigma由内核大小决定</span></span><br><span class="line"><span class="comment">#高斯滤波器——噪点减少，但也破坏图像细节</span></span><br><span class="line">median = cv2.medianBlur(image,<span class="number">5</span>)</span><br><span class="line"><span class="comment">#噪点进一步减少</span></span><br><span class="line"><span class="comment"># 一般图片只会有少数噪点，用均值滤波消除，方便后续图片操作</span></span><br></pre></td></tr></table></figure><p><strong>6. 图像特征的提取</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<span class="comment">#先转成灰度</span></span><br><span class="line">corners = cv2.goodFeaturesToTrack(gray, <span class="number">100</span>, <span class="number">0.01</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> corner <span class="keyword">in</span> corners:</span><br><span class="line">    x, y = corner.ravel()</span><br><span class="line">    cv2.circle(image, (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)), <span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#通过绘制圆来标记特征点</span></span><br></pre></td></tr></table></figure><p><strong>7. 模板匹配</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = gray[<span class="number">75</span>:<span class="number">105</span>, <span class="number">235</span>:<span class="number">265</span>]</span><br><span class="line"><span class="comment">#挑出特征区域</span></span><br><span class="line"><span class="keyword">match</span> = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line"><span class="comment">#cv2.TM_CCOEFF_NORMED为标准相关匹配算法，将两个图像标准化，再计算匹配度</span></span><br><span class="line"></span><br><span class="line">locations = np.where(<span class="keyword">match</span> &gt;= <span class="number">0.9</span>)</span><br><span class="line"><span class="comment">#locations里含有多个匹配上的特征模板的位置坐标</span></span><br><span class="line">w, h = template.shape[<span class="number">0</span>:<span class="number">2</span>]<span class="comment">#得到template的长和宽</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">zip</span>(*locations[::-<span class="number">1</span>]):</span><br><span class="line"><span class="comment">#注意python中数组调用方法</span></span><br><span class="line"><span class="comment">#[::-1] 是 Python 中切片操作的一种写法，它的作用是将 locations 进行反转。例如，如果 locations = [1, 2, 3]，那么 locations[::-1] 的结果就是 [3, 2, 1]</span></span><br><span class="line"><span class="comment">#* 是 Python 中的解包运算符。它的作用是将 locations[::-1] 这个可迭代对象中的元素解包出来。假设 locations = [[1, 2], [3, 4]]，那么 locations[::-1] 为 [[3, 4], [1, 2]]，*locations[::-1] 就会把 [3, 4] 和 [1, 2] 作为独立的参数传递给后续的函数或操作。</span></span><br><span class="line"><span class="comment">#zip() 是 Python 的内置函数，它接受多个可迭代对象作为参数，将这些可迭代对象中对应位置的元素打包成一个个元组，然后返回由这些元组组成的迭代器。例如，zip([1, 2], [3, 4]) 会返回一个迭代器，迭代器中的元素为 (1, 3) 和 (2, 4)。结合前面的解包操作，zip(*locations[::-1]) 会对反转后的 locations 中每个可迭代元素进行对应位置的打包。</span></span><br><span class="line">    x1, y1 = p[<span class="number">0</span>], p[<span class="number">1</span>]</span><br><span class="line">    x2, y2 = x1 + w, y1 + h</span><br><span class="line">    cv2.rectangle(image, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"><span class="comment">#此方法对大小敏感。若要找出所有大小的，则放缩图片多试几次</span></span><br></pre></td></tr></table></figure><p><strong>8. 图像的梯度算法</strong><br>图像梯度 &#x3D; 图像明暗变化<br>所以，颜色变化越迅速，即梯度下降越快，颜色越浅<br>（在灰度图下，则可以用作边缘检测）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.imread(<span class="string">&#x27;opencv_logo.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">laplacian = cv2.Laplacian(image, cv2.CV_64F)</span><br><span class="line"><span class="comment">#拉普拉斯算子，大致对应图像的二阶导数</span></span><br><span class="line">canny = cv2.Canny(image, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">#卡尼算法，使用梯度区间来定义边缘</span></span><br><span class="line"><span class="comment">#梯度大于200，确定为边缘。小于100，确定为非边缘</span></span><br></pre></td></tr></table></figure><p><strong>9. 阈值算法</strong><br>即二值化算法，将灰度图像分为黑与白<br>*注意Photoshop与opencv的共通</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ret, thresh = cv2.threshold(image, <span class="number">10</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment">#阈值为10，最大灰度255</span></span><br><span class="line">binary_adaptive = cv2.adaptiveThreshold(image, <span class="number">255</span>,</span><br><span class="line">                    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,<span class="number">115</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#分区域，每个区域设置不同自适应阈值</span></span><br><span class="line">ret1, binary_otsu = cv2.threshold(image, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"><span class="comment">#大金算法，不需要人为的确定阈值——聚类分析算法</span></span><br></pre></td></tr></table></figure><p><strong>10. 图像形态学（其中的腐蚀与膨胀）</strong><br>操作需要基于二值化图像<br>腐蚀与膨胀，常用于清理图像边缘细节<br>交替使用腐蚀与膨胀，可以获得更多细节，比如封闭与空腔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_, binary = cv2.threshold(image, <span class="number">200</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line"><span class="comment">#二值化，使用反向阈值</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">erosion = cv2.erode(binary, kernel, iterations=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#使用kernel来腐蚀binary</span></span><br><span class="line">dilation = cv2.dilate(binary, kernel, iterations=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#使用kernel来膨胀binary</span></span><br></pre></td></tr></table></figure><p><strong>11. 使用电脑的摄像头</strong>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#摄像头序号</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#重复读取每一帧</span></span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;camera&#x27;</span>,frame)</span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">capture.release()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/01/23/2025-01-23-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/23/2025-01-23-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>PS:<br>在编程时，新建项目时，存储的地方<br>VS，新建的项目自成文件夹，项目名是文件夹名<br>Keil，不会自成文件夹，项目名是dja文件名</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
